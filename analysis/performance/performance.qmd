---
title: "Assess the performance of the test"
format:
  html:
    embed-resources: true
    self-contained-math: true
execute: 
  warning: false
  message: false
---

```{r, message=FALSE, warning=FALSE}
pacman::p_load(outbreaker2, ape, igraph, vegan, distcrete, tidyverse, scales)
pacman::p_load_gh("CyGei/simulacr")
pacman::p_load_gh("CyGei/o2ools") # helper functions for outbreaker2
devtools::load_all()

```

# Helper functions

-   `label_ids()` reassigns the identifiers in the specified id columns of a data frame to new sequential labels ordered by the date column.

    ```{r}
    label_ids <- function(id, date) {
      ordered_ids <- id[order(date)]
      new_labels <- as.character(seq_along(ordered_ids))
      setNames(new_labels, ordered_ids)[id]
    }

    relabel_tree <- function(df, id_cols, date_col = "date_onset") {
      ids <- label_ids(df[[id_cols[1]]], df[[date_col]]) # Use the first column for labelling

      # Apply the relabelling all specified id columns
      for (col in id_cols) {
    df[[col]] <- ids[df[[col]]]
      }

      df
    }
    ```

-   `*_epicontacts` converts transmission trees to `epicontacts` objects.

    ```{r}
    make_epicontacts <- function(tree) {
      epicontacts::make_epicontacts(
    linelist = subset(tree, select = -source),
    contacts = subset(tree, select = c(source, id)),
    na_rm_contacts = TRUE,
    directed = TRUE
      )
    }

    plot_epicontacts <- function(epicontacts, x_axis = "date_onset") {
      plot(epicontacts, x_axis = x_axis)
    }
    ```

# Convergence test

> Do independent MCMC chains of `outbreaker2` converge to the same posterior distribution of transmission trees?

## Purpose

This section validates the convergence of outbreak reconstruction using `outbreaker2`. We assess whether independent MCMC chains yield statistically similar posterior distributions of transmission trees. If `outbreaker2` has properly converged, differences between chains should be non-significant (p-value \> 0.05).

## Null Hypothesis

The MCMC samples stem from same posterior distribution of transmission trees.

### Methodology

1.  **Simulate an outbreak**
    -   A synthetic transmission tree is generated using `simulacr::simulate_outbreak`\#
2.  **Reconstruct the outbreak, twice (two MCMC chains)**
    -   The same input data is used to generate two independent MCMC chains using `outbreaker2`.
    -   Each chain runs with a different random seed.
    -   We assess the quality of the reconstructed outbreaks and ensure sufficient accuracy / low entropy.
3.  **Compare chains**
    -   Apply `compare_chains` using PERMANOVA (`adonis2`) to test for statistical differences.
    -   If `outbreaker2` has converged, the test should be non-significant (p-value \> 0.05).

### Code

#### True transmission tree

```{r}
set.seed(123)
sim <- simulacr::simulate_outbreak(
  duration = 100,
  population_size = 100,
  R_values = sample(1:3, size = 100, replace = TRUE),
  dist_incubation = outbreaker2::fake_outbreak$w,
  dist_generation_time = outbreaker2::fake_outbreak$w
)$data
sim <- relabel_tree(sim, id_cols = c("id", "source"), date_col = "date_onset")
sim %>%
  make_epicontacts() %>%
  plot_epicontacts()
```

#### Outbreak reconstruction

##### Data & configuration

```{r}
data <- outbreaker_data(
  dates = sim$date_onset,
  w_dens = outbreaker2::fake_outbreak$w,
  f_dens = outbreaker2::fake_outbreak$w,
  ctd = sim[2:5, c("source", "id")], #add some contacts to improve accuracy
  ids = sim$id
)
config <- create_config(
  init_pi = 1,
  move_pi = FALSE,
  find_import = FALSE
)
```

##### `outbreaker2`

```{r}
set.seed(1)
out1 <- outbreaker(
  data = data,
  config = config
)

set.seed(2)
out2 <- outbreaker(
  data = data,
  config = config
)
```

##### Assess reconstruction

Code hidden for conciseness.

```{r, include=FALSE}
plot(out1)
plot(out2)
out1 <- out1[out1$step > 1000, ]
out2 <- out2[out2$step > 1000, ]
o2ools::get_entropy(out1)
o2ools::get_entropy(out2)

trees1 <- o2ools::get_trees(out1, data$ids)
trees2 <- o2ools::get_trees(out2, data$ids)

o2ools::get_accuracy(
  est_tt = trees1,
  true_tt = data.frame(from = sim$source, to = data$ids)
) %>%
  hist(breaks = seq(from = 0, to = 1, by = 0.1))
o2ools::get_accuracy(
  est_tt = trees2,
  true_tt = data.frame(from = sim$source, to = data$ids)
) %>%
  hist(breaks = seq(from = 0, to = 1, by = 0.1))
```

#### `compare_chains`

```{r}
# Process tress for `compare_chains` (i.e. remove introductions)
trees1 <- lapply(trees1, process_tree)
trees2 <- lapply(trees2, process_tree)
compare_chains(trees1, trees2)
```

#### More than 2 chains

We can run as many independent chains as we like and feed them into `compare_chains`. The p-value should remain \> 0.05.

```{r}
trees <- lapply(1:5, function(i) {
  #set.seed(i)
  out <- outbreaker(data = data, config = config)
  out <- out[out$step > 1000, ]
  trees <- o2ools::get_trees(out, data$ids)
  trees <- lapply(trees, process_tree)
})
do.call(compare_chains, trees)
```

# Common epi characteristics

> Does the test "correctly" fail to detect a significant difference when applied to outbreaks with identical epidemiological characteristics?

## Purpose

This section evaluates whether the test "correctly" detects no significant difference when applied to two outbreaks generated from identical epidemiological characteristics.

## Null Hypothesis

The (two or more!) MCMC chains come from transmission trees generated with the same parameters.

### Methodology

1.  **Simulate two outbreaks**
    -   Two synthetic transmission trees generated with `simulacr::simulate_outbreak` using identical epidemiological parameters.
2.  **Reconstruct the outbreaks**
    -   We reconstruct each outbreak with `outbreaker2`.
    -   Assess reconstruction quality by ensuring sufficient accuracy and low entropy.
3.  **Compare chains**
    -   Apply `compare_chains` between the two posterior distributions of transmission trees.
    -   Since both outbreaks share the same epidemiological characteristics (e.g., case counts, offspring distribution, generation time), no significant difference should be detected if the test performs correctly.

### Code

Note that even with the same parameters, the number of cases may vary. We ensure that we always end up with 18 cases in the below.

#### Oubtreak simulation

```{r}
n_iter <- 2
sims <- lapply(seq_len(n_iter), function(i) {
  set.seed(i)
  repeat {
    sim <- simulacr::simulate_outbreak(
      duration = 100,
      population_size = 20,
      R_values = sample(1:3, size = 100, replace = TRUE),
      dist_incubation = outbreaker2::fake_outbreak$w,
      dist_generation_time = outbreaker2::fake_outbreak$w
    )$data
    if (nrow(sim) == 18) break # Keep sim only if it reaches 18 cases
  }
  sim <- relabel_tree(sim,
    id_cols = c("id", "source"),
    date_col = "date_onset"
  )
})
```

#### Oubtreak reconstruction

```{r}
perc_ctd <- 0.6 # take X% of ctd data to improve reconstruction

trees <- lapply(seq_len(n_iter), function(i) {
  sim <- sims[[i]]

  # sample from ctd data
  n_ctd <- round(nrow(sim) * perc_ctd)
  ctd_indices <- sample(x = 2:nrow(sim), size = n_ctd, replace = FALSE)

  data <- outbreaker_data(
    dates = sim$date_onset,
    w_dens = outbreaker2::fake_outbreak$w,
    f_dens = outbreaker2::fake_outbreak$w,
    ctd = sim[ctd_indices, c("source", "id")],
    ids = sim$id
  )
  config <- create_config(
    init_pi = 1,
    move_pi = FALSE,
    find_import = FALSE
    # ctd_directed = TRUE
  )
  set.seed(i)
  out <- outbreaker(data = data, config = config)
  out <- out[out$step > 1000, ]
  trees <- o2ools::get_trees(out, data$ids)
  trees <- lapply(trees, process_tree)
})
```

```{r}
do.call(compare_chains, trees)
```

# Next step

We perform a sensitivity analysis on two posterior chains of transmission trees (`chain_A`, `chain_B`) to investigate how the **sample size** (`sample_sizes`), the epidemic size (`epidemic_sizes`) and the **proportion of overlap** between the two chains (`overlap_freqs`) affect the performance of the test (`compare_chains`). See `run_analysis.R`

```{r}
sample_sizes <- c(10, 50, 100, 500)
overlap_freqs <- seq(0, 1, by = 0.2)
epidemic_sizes <- c(20, 100, 200)
results <- readRDS("~/PROJECTS_LOCAL/epitree/analysis/performance/data/2025-02-03/results.rds")
```



```{r}
library(tidyverse, ggplot2, ggh4x)
df <- lapply(seq_along(results), function(i) {
  as.data.frame.table(results[[i]]) %>%
    mutate(epidemic_size = epidemic_sizes[i])
}) %>%
  bind_rows() %>%
  mutate(epidemic_size = factor(epidemic_size, levels = epidemic_sizes)) %>%
  rename(p_value = Freq)

alpha <- 0.05
annotations_df <- df %>%
  group_by(epidemic_size, sample_size, overlap_freq) %>%
  summarise(reject = mean(p_value < alpha) * 100,
            accept = mean(p_value >= alpha) * 100,
            .groups = "drop") %>%
  pivot_longer(
    cols = c("reject", "accept"),
    names_to = "category",
    values_to = "percentage"
  ) %>%
  mutate(
    row_title = "Epidemic Size",
    col_title = "Posterior Sample Size")

str(annotations_df)


p_props <- annotations_df %>%
  ggplot() +
  aes(x = percentage,
      y = factor(overlap_freq),
      fill = category) +
  ggh4x::facet_nested(
    rows = vars(row_title, epidemic_size),
    cols = vars(col_title, sample_size),
    scales = "fixed",
    space = "fixed",
    remove_labels = "none",
    nest_line = element_line(colour = "grey")
  )+
  geom_bar(stat = "identity",
           position = "stack",
           width = 0.7) +
  geom_text(
    aes(
      x = ifelse(category == "reject", percentage / 2, 100 - percentage / 2),
      label = ifelse(percentage > 0, round(percentage, 1), "")
    ),
    position = position_stack(vjust = 0.5),
    colour = "black",
    size = 3
  ) +
  scale_fill_manual(
    values =
      c(
        "reject" = "#FAD2CF",
        "accept" = "#CEEAD6"
      ),
    breaks = c("reject", "accept"),
    name = "P-value",
    labels = c("reject" = "Reject Null", "accept" = "Accept Null")
  ) +
  coord_cartesian(xlim = c(0, 100)) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "white",
      colour = "black",
      linewidth = 0.5
    ),
    strip.text = element_text(family = "Fira Code",
                              #face = "bold",
                              size = 10),
    plot.title = element_text(size=12)
  ) +
  labs(x = "Percentage",
       y = "Overlap Frequency",
       title = "Proportion of p-values </> 0.05 by Overlap Frequency, Sample Size, and Epidemic Size")
p_props

#############################
# Test results
#############################
library(broom)
model_df <- df %>%
  mutate(
    category = ifelse(p_value < alpha, "reject", "accept"),
    reject = ifelse(p_value < alpha, 1, 0),
    accept = ifelse(p_value >= alpha, 1, 0),
  ) %>%
  select(epidemic_size,
         sample_size,
         overlap_freq,
         category,
         reject,
         accept)
#############################
# Chi-square test
#############################

chisq.test(table(model_df$category, model_df$epidemic_size))
chisq.test(table(model_df$category, model_df$sample_size))

#############################
# Logistic regression
#############################
# The logistic regression model is used to determine the effect of
# the overlap frequency and sample size on the probability of rejecting the null hypothesis.


glm(
  reject ~ sample_size,
  data = model_df,
  family = binomial(link = "logit")
) %>%
  broom::tidy() %>%
  mutate(OR = exp(estimate))

m1 <- glm(
  reject ~ sample_size + epidemic_size + as.numeric(as.character(overlap_freq)),
  data = model_df,
  family = binomial(link = "logit")
) %>%
  broom::tidy() %>%
  mutate(
    OR = exp(estimate),
    lower_ci = exp(estimate - 1.96 * std.error),
    upper_ci = exp(estimate + 1.96 * std.error)
  ) %>%
  filter(term != "(Intercept)")

ggplot(m1, aes(y = term, x = OR)) +
  geom_point() +
  geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci),
                 height = 0.2) +
  geom_vline(xintercept = 1,
             linetype = "dashed",
             color = "red") +
  scale_x_log10() +  # Log scale for better visualization of ORs
  labs(title = "Odds Ratios with 95% Confidence Intervals", x = "Odds Ratio (log scale)", y = "Variable") +
  theme_minimal()

```
