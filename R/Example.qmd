---
title: "Compare posterior sets of transmission trees"
format: html

execute: 
  warning: false
  message: false
---

# Load libraries & scripts

```{r}
pacman::p_load(outbreaker2, ape, igraph, vegan, distcrete, ggplot2, scales)
pacman::p_load_gh("CyGei/o2ools")
source(here::here("R", "internals.R"))
source(here::here("R", "distances.R"))
```

# `outbreaker2` chains

We are using the default `outbreaker2` data from the [vignette](https://cran.r-project.org/web/packages/outbreaker2/vignettes/introduction.html). But will distinguish the two chains by using different generation time distributions (`gt`).

```{r}
linelist <- data.frame(
  ids = as.character(1:30),
  dates = outbreaker2::fake_outbreak$sample
)

# Define two distinct gamma distributions
gt <- lapply(list(
  distcrete("gamma", interval = 1, shape = 2, scale = 3, w = 0.5),
  distcrete("gamma", interval = 1, shape = 2.5, scale = 5, w = 0.5)
), function(d) d$d(1:50))

# Plot the two gamma distributions
plot(1:50, gt[[1]],
  type = "l", col = "blue", lwd = 2,
  xlab = "Time", ylab = "Density", main = "Two Distinct Gamma Distributions"
)
lines(1:50, gt[[2]], col = "red", lwd = 2)
legend("topright",
  legend = c("Shape=2, Scale=5", "Shape=8, Scale=2"),
  col = c("blue", "red"), lwd = 2
)

```

And run multiple (`n_chains`) instances of `outbreaker2`, with **different** generation time distributions. The below will result in `n` distinct posterior chains of transmission trees.

```{r}
n_chains <- 2

set.seed(1)
chains <-
  lapply(1:n_chains, function(i) {
    x <- outbreaker2::outbreaker(
      data = outbreaker2::outbreaker_data(
        dna = outbreaker2::fake_outbreak$dna,
        dates = outbreaker2::fake_outbreak$sample,
        ctd = outbreaker2::fake_outbreak$ctd,
        w_dens = gt[[i]],
        ids = linelist$ids
      ),
      config = outbreaker2::create_config(
        init_pi = 1,
        move_pi = FALSE,
        find_import = FALSE
      )
    )
    x <- x[x$step > 1000, ] # burnin
  })

```

Trace plots of the posterior for each chain

```{r}
plot(chains[[1]])
plot(chains[[2]])
```

## Posterior transmission trees

For each chain, we use the package `o2ools` to convert the default `outbreaker2` dataframe into a list of transmission trees.

```{r}

trees <- lapply(chains, function(chain) {
  t <- o2ools::get_trees(out = chain, ids = linelist$ids, kappa = FALSE)
  t <- lapply(t, function(df) df[-1, ]) # remove introduction
  invisible(lapply(t, check_tree)) # check that the tree has a 'simple' form (see internals.R)
  return(t)
})

cat(
  "Length of chain #1:", length(trees[[1]]),
  " | Length of chain #2:", length(trees[[2]]), "\n"
)
```

# Compare posterior sets of transmission trees

`compare_trees` (see *distances.R*) is the main function used to compare two posterior sets of transmission trees.

```{r, eval=FALSE}
compare_trees(..., f_within = patristic, f_between = euclidean, adonis2_args = list())

compare_trees(trees[[1]], trees[[2]], adonis2_args = list(permutations = 2000))
```

-   `...` : `n` lists of data frames representing transmission trees (n\>=2). Each data frame contains a `from` and `to` column with entries representing case IDs present in the linelist.

-   `f_within` : function to compute the distance between nodes within a tree. Must return a square matrix.

-   `f_between` : function to compute the distance between two trees. Must return a square matrix.

-   `adonis2_args` : list containing additional arguments for `vegan::adonis2()`.

## Compare two identical chains

First we ensure that `compare_trees` returns non-significant p-values for trees sampled from the same chain.

```{r}
set.seed(123)
sample1 <- sample(trees[[1]], size = 50, replace = TRUE)
sample2 <- sample(trees[[1]], size = 50, replace = TRUE)

compare_chains(sample1, sample2)
```

There is no statistically significant difference between the two samples from the same chain.

Note the [paper](https://onlinelibrary.wiley.com/doi/10.1111/j.1442-9993.2001.01070.pp.x) from Anderson states that there is a ***dispersion*** (variance within group) effect. Even when the ***location*** (i.e. the *centroid* of the group) is the same between two groups, greater dispersion in one group may yield significant differences. We could test this by running 2 iterations of `outbreaker2` one with priors with high uncertainty and one with low uncertainty @Thibaut ?

## Compare two distinct chains

```{r}
compare_chains(trees[[1]], trees[[2]])
```

There is a statistically significant difference between the two samples from the two distinct chains.

## Sensitivity Analysis

We want to check whether the test is sensitive to:

1.  The sample size (`n_trees`)

2.  The proportion of trees that are common in both chains (`freq_common`). Here we want to test when will the test return a p-value \> 0.05 as the % of identical trees in both chain increases.

```{r}
# Evaluate how the proportion of shared trees affects the p-value by n_trees
n_trees <- c(10, 75, 150)
freq_common  <- seq(0, 1, by = 0.05)
results <- do.call(rbind, lapply(n_trees, function(n) {

  ref_chain <- trees[[1]][sample(1:length(trees[[1]]), n)]
  mixed_chain <- trees[[2]][sample(1:length(trees[[2]]), n)]

  # Compute p-values for each freq_common
  data.frame(
    n_trees = rep(n, length(freq_common)),
    freq_common = freq_common,
    p_value = sapply(freq_common, function(perc) {
      n_replace <- round(perc * n)

      # Create the mixed chain (that contains freq_common trees from the reference chain)
      new_mixed <- c(
        sample(mixed_chain, n - n_replace, replace = FALSE),
        sample(ref_chain, n_replace, replace = FALSE)
      )
      new_mixed <- sample(new_mixed, length(new_mixed))

      adonis_result <- compare_chains(ref_chain, new_mixed)
      adonis_result[1, "Pr(>F)"]
    })
  )
}))
```

```{r}
results$n_trees <- as.factor(results$n_trees)
ggplot(results,
       aes(
         x = freq_common,
         y = p_value,
         color = n_trees,
         group = n_trees
       )) +
  geom_line() +
  geom_point() +
  geom_hline(yintercept = 0.05, linetype = "dashed") +
  labs(x = "Proportion of trees from reference chain", y = "p-value") +
  scale_y_log10(breaks = c(0.001, 0.010, 0.05, 0.1, 1)) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10),
                     labels = scales::percent_format()) +
  theme_bw()

```

## Using alternative distance functions

See Kendall's [paper](https://projecteuclid.org/journals/statistical-science/volume-33/issue-1/Estimating-Transmission-from-Genetic-and-Epidemiological-Data--A-Metric/10.1214/17-STS637.full)and [vignette](https://thibautjombart.github.io/treespace/articles/TransmissionTreesVignette.html)from `treespace`.

### Specify the user defined function

```{r}
pacman::p_load(treespace)

mrciDepth <- function(tree) {
  treespace::findMRCIs(as.matrix(tree))$mrciDepths
}

compare_chains(trees[[1]], trees[[2]], f_within = mrciDepth)
compare_chains(sample1, sample2, f_within = mrciDepth)
```

Let's create a distributions of p-values comparing two samples from the same chain with separate `f_within` functions:

```{r}
patristic <- replicate(100, {
  sample1 <- sample(trees[[1]], size = 50, replace = TRUE)
  sample2 <- sample(trees[[1]], size = 50, replace = TRUE)   
  compare_chains(sample1, sample2)[["Pr(>F)"]][[1]]
})

kendall <- replicate(100, {
  sample1 <- sample(trees[[1]], size = 50, replace = TRUE)
  sample2 <- sample(trees[[1]], size = 50, replace = TRUE)   
  compare_chains(sample1, sample2, f_within = mrciDepth)[["Pr(>F)"]][[1]]
})


ggplot(data.frame(method = c(rep("patristic", 100), rep("kendall", 100)),
                  pvalue = c(patristic, kendall)),
       aes(x = pvalue, fill = method)) +
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 0.05, linetype = "dashed") 
```

We also checked whether the chi square test could work.

```{r}
# chisq test ----------------------------------------------------
pacman::p_load(tidyverse, magrittr)
ttabx <- sample(trees[[1]], size = 100, replace = TRUE) %$%
  bind_rows(.) %$%
  o2ools::ttable(from = .$from, to = .$to, levels = linelist$ids) 

ttaby <- sample(trees[[1]], size = 100, replace = TRUE) %$%
  bind_rows(.) %$%
  o2ools::ttable(from = .$from, to = .$to, levels = linelist$ids)

vegan::mantel(as.matrix(ttabx), as.matrix(ttaby)) # Ask @Thibaut if worth checking out 

#chi-square is not suitable due to sample size sensitivity 
get_chisq(
  chain_x = sample(trees[[1]], size = 100, replace = TRUE),
  chain_y = sample(trees[[1]], size = 100, replace = TRUE),
  levels = linelist$ids
)

replicate(n = 100, {
  tryCatch(
    {
      p.value <- get_chisq(
        chain_x = sample(trees[[1]], size = 1, replace = TRUE),
        chain_y = sample(trees[[1]], size = 1, replace = TRUE),
        levels = linelist$ids
      )$p.value
      p.value
    },
    error = function(e) {
      NA  # Return NA if there's an error
    }
  )
}) |> 
  as_tibble() |> 
  ggplot(aes(x = value))+
  geom_density()+
  geom_vline(xintercept = 0.05, lty = "dashed")+
  labs(x = "p-value")

```